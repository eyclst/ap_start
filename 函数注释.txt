/**
 * ieee80211_start_ap - 初始化AP接口
 * @wiphy: 无线物理层设备结构体
 * @dev: 网络设备结构体
 * @params: AP设置参数
 *
 * 该函数用于初始化一个802.11接入点（AP）接口。它配置了AP的各种参数，如SSID、信道、 Beacon间隔等。
 * 在成功初始化后，AP将准备好接受客户端的连接请求。
 *
 * 返回值:
 *   0: AP初始化成功
 *  -EALREADY: AP已初始化
 *  -ENOTSUPP: 不支持的SMPS模式
 * 其他错误码: 配置AP参数时发生错误
 */
static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
			      struct cfg80211_ap_settings *params)
{
	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
	struct ieee80211_local *local = sdata->local;
	struct beacon_data *old;
	struct ieee80211_sub_if_data *vlan;
	u32 changed = BSS_CHANGED_BEACON_INT |
		      BSS_CHANGED_BEACON_ENABLED |
		      BSS_CHANGED_BEACON |
		      BSS_CHANGED_SSID |
		      BSS_CHANGED_P2P_PS |
		      BSS_CHANGED_TXPOWER |
		      BSS_CHANGED_TWT;
	int i, err;
	int prev_beacon_int;

	/* 检查是否已经存在一个有效的Beacon，如果存在则表示AP已经启动 */
	old = sdata_dereference(sdata->u.ap.beacon, sdata);
	if (old)
		return -EALREADY;

	/* 当前只支持关闭SMPS模式，其他模式不支持 */
	if (params->smps_mode != NL80211_SMPS_OFF)
		return -ENOTSUPP;

	/* 初始化SMPS模式为关闭状态 */
	sdata->smps_mode = IEEE80211_SMPS_OFF;

	/* 设置接收链路所需的链路模式 */
	sdata->needed_rx_chains = sdata->local->rx_chains;

	/* 保存之前的Beacon间隔，以便在失败时恢复 */
	prev_beacon_int = sdata->vif.bss_conf.beacon_int;
	/* 设置新的Beacon间隔 */
	sdata->vif.bss_conf.beacon_int = params->beacon_interval;

	/* 配置HE相关参数 */
	if (params->he_cap && params->he_oper) {
		sdata->vif.bss_conf.he_support = true;
		sdata->vif.bss_conf.htc_trig_based_pkt_ext =
			le32_get_bits(params->he_oper->he_oper_params,
			      IEEE80211_HE_OPERATION_DFLT_PE_DURATION_MASK);
		sdata->vif.bss_conf.frame_time_rts_th =
			le32_get_bits(params->he_oper->he_oper_params,
			      IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);
		changed |= BSS_CHANGED_HE_OBSS_PD;

		if (params->he_bss_color.enabled)
			changed |= BSS_CHANGED_HE_BSS_COLOR;
	}

	/* 加锁以保护频道资源 */
	mutex_lock(&local->mtx);
	/* 使用指定的频道配置 */
	err = ieee80211_vif_use_channel(sdata, &params->chandef,
					IEEE80211_CHANCTX_SHARED);
	if (!err)
		/* 复制频道配置给所有VLAN */
		ieee80211_vif_copy_chanctx_to_vlans(sdata, false);
	mutex_unlock(&local->mtx);
	if (err) {
		/* 如果配置频道失败，恢复之前的Beacon间隔 */
		sdata->vif.bss_conf.beacon_int = prev_beacon_int;
		return err;
	}

	/* 应用控制端口协议配置 */
	/*
	 * Apply control port protocol, this allows us to
	 * not encrypt dynamic WEP control frames.
	 */
	sdata->control_port_protocol = params->crypto.control_port_ethertype;
	sdata->control_port_no_encrypt = params->crypto.control_port_no_encrypt;
	sdata->control_port_over_nl80211 =
				params->crypto.control_port_over_nl80211;
	sdata->control_port_no_preauth =
				params->crypto.control_port_no_preauth;
	/* 根据加密配置计算加密头部预留空间 */
	sdata->encrypt_headroom = ieee80211_cs_headroom(sdata->local,
							&params->crypto,
							sdata->vif.type);

	/* 遍历所有VLAN接口，应用相同的控制端口配置 */
	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list) {
		vlan->control_port_protocol =
			params->crypto.control_port_ethertype;
		vlan->control_port_no_encrypt =
			params->crypto.control_port_no_encrypt;
		vlan->control_port_over_nl80211 =
			params->crypto.control_port_over_nl80211;
		vlan->control_port_no_preauth =
			params->crypto.control_port_no_preauth;
		vlan->encrypt_headroom =
			ieee80211_cs_headroom(sdata->local,
					      &params->crypto,
					      vlan->vif.type);
	}

	/* 配置DTIM周期、允许P2P GO省电和TWT支持等参数 */
	sdata->vif.bss_conf.dtim_period = params->dtim_period;
	sdata->vif.bss_conf.enable_beacon = true;
	sdata->vif.bss_conf.allow_p2p_go_ps = sdata->vif.p2p;
	sdata->vif.bss_conf.twt_responder = params->twt_responder;
	sdata->vif.bss_conf.he_obss_pd = params->he_obss_pd;
	sdata->vif.bss_conf.he_bss_color = params->he_bss_color;
	sdata->vif.bss_conf.s1g = params->chandef.chan->band ==
				  NL80211_BAND_S1GHZ;

	/* 配置SSID参数 */
	sdata->vif.bss_conf.ssid_len = params->ssid_len;
	if (params->ssid_len)
		memcpy(sdata->vif.bss_conf.ssid, params->ssid,
		       params->ssid_len);
	sdata->vif.bss_conf.hidden_ssid =
		(params->hidden_ssid != NL80211_HIDDEN_SSID_NOT_IN_USE);

	/* 初始化P2P NOA属性 */
	memset(&sdata->vif.bss_conf.p2p_noa_attr, 0,
	       sizeof(sdata->vif.bss_conf.p2p_noa_attr));
	sdata->vif.bss_conf.p2p_noa_attr.oppps_ctwindow =
		params->p2p_ctwindow & IEEE80211_P2P_OPPPS_CTWINDOW_MASK;
	if (params->p2p_opp_ps)
		sdata->vif.bss_conf.p2p_noa_attr.oppps_ctwindow |=
					IEEE80211_P2P_OPPPS_ENABLE_BIT;

	/* 初始化Beacon速率集 */
	sdata->beacon_rate_set = false;
	if (wiphy_ext_feature_isset(local->hw.wiphy,
				    NL80211_EXT_FEATURE_BEACON_RATE_LEGACY)) {
		for (i = 0; i < NUM_NL80211_BANDS; i++) {
			sdata->beacon_rateidx_mask[i] =
				params->beacon_rate.control[i].legacy;
			if (sdata->beacon_rateidx_mask[i])
				sdata->beacon_rate_set = true;
		}
	}

	/* 设置Beacon发送速率 */
	if (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL))
		sdata->vif.bss_conf.beacon_tx_rate = params->beacon_rate;

	/* 初始化Beacon */
	err = ieee80211_assign_beacon(sdata, &params->beacon, NULL, NULL);
	if (err < 0)
		goto error;
	changed |= err;

	/* 配置FILS发现机制 */
	if (params->fils_discovery.max_interval) {
		err = ieee80211_set_fils_discovery(sdata,
						   &params->fils_discovery);
		if (err < 0)
			goto error;
		changed |= BSS_CHANGED_FILS_DISCOVERY;
	}

	/* 配置应答广播探针请求的间隔 */
	if (params->unsol_bcast_probe_resp.interval) {
		err = ieee80211_set_unsol_bcast_probe_resp(sdata,
							   &params->unsol_bcast_probe_resp);
		if (err < 0)
			goto error;
		changed |= BSS_CHANGED_UNSOL_BCAST_PROBE_RESP;
	}

	/* 启动AP */
	err = drv_start_ap(sdata->local, sdata);
	if (err) {
		old = sdata_dereference(sdata->u.ap.beacon, sdata);

		if (old)
			kfree_rcu(old, rcu_head);
		RCU_INIT_POINTER(sdata->u.ap.beacon, NULL);
		goto error;
	}

	/* 重新计算DTIM */
	ieee80211_recalc_dtim(local, sdata);
	/* 通知BSS信息变更 */
	ieee80211_bss_info_change_notify(sdata, changed);

	/* 激活网络接口 */
	netif_carrier_on(dev);
	/* 激活所有VLAN接口 */
	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)
		netif_carrier_on(vlan->dev);

	return 0;

error:
	/* 释放频道资源 */
	mutex_lock(&local->mtx);
	ieee80211_vif_release_channel(sdata);
	mutex_unlock(&local->mtx);

	return err;
}








/**
 * ieee80211_stop_ap - 停止AP接口操作
 * @wiphy: 无线物理层设备结构体
 * @dev: 网络设备结构体
 *
 * 该函数用于停止一个IEEE 802.11接入点（AP）接口的操作。它涉及到取消广播帧的发送、
 * 释放频道资源、停止信标和探测响应的发送等操作。此外，它还处理了与频道切换、
 * 信道测量相关的资源清理。
 *
 * 返回值:
 * 返回0，表示成功停止AP接口；如果在取消广播帧发送过程中遇到错误，则返回相应的错误码。
 */
static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
{
    struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
    struct ieee80211_sub_if_data *vlan;
    struct ieee80211_local *local = sdata->local;
    struct beacon_data *old_beacon;
    struct probe_resp *old_probe_resp;
    struct fils_discovery_data *old_fils_discovery;
    struct unsol_bcast_probe_resp_data *old_unsol_bcast_probe_resp;
    struct cfg80211_chan_def chandef;

    /* 确保对sdata的锁定 */
    sdata_assert_lock(sdata);

    /* 取消引用并可能释放beacon和probe response资源 */
    old_beacon = sdata_dereference(sdata->u.ap.beacon, sdata);
    if (!old_beacon)
        return -ENOENT;
    old_probe_resp = sdata_dereference(sdata->u.ap.probe_resp, sdata);
    old_fils_discovery = sdata_dereference(sdata->u.ap.fils_discovery, sdata);
    old_unsol_bcast_probe_resp = sdata_dereference(sdata->u.ap.unsol_bcast_probe_resp, sdata);

    /* 中止任何正在进行的频道切换操作 */
    mutex_lock(&local->mtx);
    sdata->vif.csa_active = false;
    if (sdata->csa_block_tx) {
        ieee80211_wake_vif_queues(local, sdata, IEEE80211_QUEUE_STOP_REASON_CSA);
        sdata->csa_block_tx = false;
    }
    mutex_unlock(&local->mtx);

    /* 释放下一个要发送的beacon内存 */
    kfree(sdata->u.ap.next_beacon);
    sdata->u.ap.next_beacon = NULL;

    /* 关闭接口和关联VLAN的载波 */
    list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)
        netif_carrier_off(vlan->dev);
    netif_carrier_off(dev);

    /* 清除beacon和probe response指针，并释放相应的内存 */
    RCU_INIT_POINTER(sdata->u.ap.beacon, NULL);
    RCU_INIT_POINTER(sdata->u.ap.probe_resp, NULL);
    RCU_INIT_POINTER(sdata->u.ap.fils_discovery, NULL);
    RCU_INIT_POINTER(sdata->u.ap.unsol_bcast_probe_resp, NULL);
    kfree_rcu(old_beacon, rcu_head);
    if (old_probe_resp)
        kfree_rcu(old_probe_resp, rcu_head);
    if (old_fils_discovery)
        kfree_rcu(old_fils_discovery, rcu_head);
    if (old_unsol_bcast_probe_resp)
        kfree_rcu(old_unsol_bcast_probe_resp, rcu_head);

    /* 释放FTMR参数内存 */
    kfree(sdata->vif.bss_conf.ftmr_params);
    sdata->vif.bss_conf.ftmr_params = NULL;

    /* 清理关联的STA信息和密钥 */
    __sta_info_flush(sdata, true);
    ieee80211_free_keys(sdata, true);

    /* 禁用beacon并重置相关配置 */
    sdata->vif.bss_conf.enable_beacon = false;
    sdata->beacon_rate_set = false;
    sdata->vif.bss_conf.ssid_len = 0;
    clear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED, &sdata->state);
    ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED);

    /* 如果正在进行频道测量，则取消测量并通知用户空间 */
    if (sdata->wdev.cac_started) {
        chandef = sdata->vif.bss_conf.chandef;
        cancel_delayed_work_sync(&sdata->dfs_cac_timer_work);
        cfg80211_cac_event(sdata->dev, &chandef, NL80211_RADAR_CAC_ABORTED, GFP_KERNEL);
    }

    /* 调用驱动程序停止AP操作 */
    drv_stop_ap(local, sdata);

    /* 清理广播帧缓冲区 */
    local->total_ps_buffered -= skb_queue_len(&sdata->u.ap.ps.bc_buf);
    ieee80211_purge_tx_queue(&local->hw, &sdata->u.ap.ps.bc_buf);

    /* 释放频道资源并更新VLAN的频道上下文 */
    mutex_lock(&local->mtx);
    ieee80211_vif_copy_chanctx_to_vlans(sdata, true);
    ieee80211_vif_release_channel(sdata);
    mutex_unlock(&local->mtx);

    return 0;
}